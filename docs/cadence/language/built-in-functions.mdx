---
title: Built-in Functions
sidebar_position: 28
---

## `panic`
#

```cadence
fun panic(_ message: String): Never
```

Terminates the program unconditionally
and reports a message which explains why the unrecoverable error occurred.

```cadence
panic("something went wrong: ...")
```

## `assert`

```cadence
fun assert(_ condition: Bool, message: String)
```

Terminates the program if the given condition is false,
and reports a message which explains how the condition is false.
Use this function for internal sanity checks.

The message argument is optional.

## `revertibleRandom`

```cadence
fun revertibleRandom(): UInt64
```

<Callout type="info">
`unsafeRandom()` function currently behaves the same way as `revertibleRandom()`.
`unsafeRandom` will be deprecated in the next release of Cadence. 
</Callout>

Returns a pseudo-random number.

The random number returned is safe as it is backed by a distributed source of randomness,
that is unbiased, unpredictable and verifiable.

The random number cannot be biased or predicted by miners or by other transactions or code
running before a call to `revertibleRandom`.

Moreover, the sequence of returned random numbers is different per block, and per transaction
within the same block.

<Callout type="warning">
There is an additional safety-relevant aspect that developers need to be mindful about.

The function is not immune to post-selection manipulation by a non-trusted party where
a random number is sampled and then rejected.

A transaction can atomically revert all its actions.
Therefore, it is possible for a transaction calling into a smart contract
to post-select favorable results and revert the transaction for unfavorable results.

The function remains totally safe when called by a trusted party.

This limitation is inherent to any smart contract platform that allows transactions to roll back atomically
and cannot be solved through safe randomness alone. Flow protocol has suggested a [solution to implement safe
commit-reveal schemes](https://github.com/onflow/flips/pull/123) and address this limitation.
</Callout>

## `RLP`

Recursive Length Prefix (RLP) serialization allows the encoding of arbitrarily nested arrays of binary data.

Cadence provides RLP decoding functions in the built-in `RLP` contract, which does not need to be imported.

### `decodeString`

```cadence
fun decodeString(_ input: [UInt8]): [UInt8]
```

Decodes an RLP-encoded byte array. RLP calls this a "string."
The byte array should only contain of a single encoded value for a string.
If the encoded value type does not match, or it has trailing unnecessary bytes, the program aborts.
If the function encounters any error while decoding, the program aborts.

### `decodeList`

```cadence
fun decodeList(_ input: [UInt8]): [[UInt8]]`
```

Decodes an RLP-encoded list into an array of RLP-encoded items.

Note that this function does not recursively decode, so each element of the resulting array is RLP-encoded data.
The byte array should only contain of a single encoded value for a list.
If the encoded value type does not match, or it has trailing unnecessary bytes, the program aborts.
If the function encounters any error while decoding, the program aborts.
